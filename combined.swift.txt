===== ContentView.swift =====
import SwiftUI

struct ContentView: View {
    @StateObject private var scanner = NetworkScanner()

    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Button(action: {
                    print("🔵 [UI] 'Scan Network' button tapped")
                    scanner.scanNetwork()
                }) {
                    if scanner.isScanning {
                        Text("Scanning...")
                            .font(.headline)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.gray)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    } else {
                        Text("Scan Network")
                            .font(.headline)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    }
                }
                .padding(.horizontal)
                .disabled(scanner.isScanning)

                if scanner.devices.isEmpty {
                    Text("No active devices found. Tap 'Scan Network' to start.")
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                        .padding()
                } else {
                    List(scanner.devices) { device in
                        HStack {
                            Text(device.ipAddress)
                            Spacer()
                            if let port = device.openPort {
                                Text("Port \(port) open")
                                    .foregroundColor(.green)
                            } else if device.icmpResponded {
                                Text("ICMP ping")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .padding()
            .navigationTitle("Network Scanner")
        }
    }
}



===== NetworkScanner.swift =====
import Foundation
import Network
import SwiftPing
import Combine

class NetworkScanner: ObservableObject {
    @Published var devices: [Device] = []
    @Published var isScanning: Bool = false

    private let queue = DispatchQueue.global(qos: .background)

    struct Device: Identifiable {
        let id = UUID()
        let ipAddress: String
        let openPort: UInt16?
        let icmpResponded: Bool

        var isActive: Bool {
            (openPort != nil || icmpResponded)
        }
    }

    // List of common ports to check. Adjust as needed:
    private let commonPorts: [UInt16] = [22, 80, 443, 8080]

    // MARK: - Public Start
    func scanNetwork() {
        devices.removeAll()
        isScanning = true
        print("🔵 [Scanner] Starting multi-port scan...")

        guard let prefix = getLocalIPPrefix() else {
            print("⚠️ [Scanner] Could not detect local IP prefix. Aborting scan.")
            isScanning = false
            return
        }

        print("🌐 [Scanner] Detected prefix: \(prefix) => scanning .1 through .255 (common ports + optional ICMP)")

        let allIPs = (1...255).map { "\(prefix)\($0)" }

        // Process addresses in chunks of 10 to avoid extreme concurrency.
        scanNextBatch(allIPs, batchSize: 10, startIndex: 0)
    }

    // MARK: - Batch Scanning
    private func scanNextBatch(_ ipList: [String], batchSize: Int, startIndex: Int) {
        // If no more IPs to process, we’re done
        guard startIndex < ipList.count else {
            finishScanning()
            return
        }

        // Create the next sub‐array
        let endIndex = min(startIndex + batchSize, ipList.count)
        let batch = ipList[startIndex..<endIndex]

        // A dispatch group for this batch
        let batchGroup = DispatchGroup()

        // For each IP in this batch:
        for ip in batch {
            // 1) Enter the batch group once
            batchGroup.enter()

            // 2) Scan the IP on the background queue
            scanOneHost(ip) {
                // 3) On completion, leave the batch group
                batchGroup.leave()
            }
        }

        // Once the entire batch is done, move on to the next batch
        batchGroup.notify(queue: queue) {
            self.scanNextBatch(ipList, batchSize: batchSize, startIndex: endIndex)
        }
    }

    private func finishScanning() {
        DispatchQueue.main.async {
            self.isScanning = false
            print("✅ [Scanner] Finished scanning all IPs.")
        }
    }

    // MARK: - Single Host
    /**
     For one IP, we:
     - open a small `portGroup` for the ports
     - do `tcpProbe` for each port, collecting the first open port if any
     - once ports are done, do an ICMP ping
     - then call the final completion
    */
    private func scanOneHost(_ ip: String, completion: @escaping () -> Void) {
        // Record the first open port found
        var foundOpenPort: UInt16? = nil

        // A group for the ports
        let portGroup = DispatchGroup()

        // Start port checks
        for port in commonPorts {
            portGroup.enter()
            tcpProbeIPAddress(ip, port: port) { didConnect in
                if didConnect, foundOpenPort == nil {
                    foundOpenPort = port
                }
                portGroup.leave()
            }
        }

        // Once all ports are tested, do an ICMP ping
        portGroup.notify(queue: queue) {
            self.pingIPAddressICMP(ip) { didPing in
                DispatchQueue.main.async {
                    // If either a port was open or ICMP replied, we add it to devices
                    if foundOpenPort != nil || didPing {
                        let dev = Device(ipAddress: ip,
                                         openPort: foundOpenPort,
                                         icmpResponded: didPing)
                        self.devices.append(dev)
                        print("   → [Scan] \(ip): port=\(String(describing: foundOpenPort)), ping=\(didPing) => Active!")
                    } else {
                        print("   → [Scan] \(ip): no ports open, no ping => Inactive (not added)")
                    }
                    // Signal back that we’re done scanning this IP
                    completion()
                }
            }
        }
    }

    // MARK: - TCP
    private func tcpProbeIPAddress(_ ip: String, port: UInt16, completion: @escaping (Bool) -> Void) {
        guard let nwPort = NWEndpoint.Port(rawValue: port) else {
            completion(false)
            return
        }
        let endpoint = NWEndpoint.hostPort(host: NWEndpoint.Host(ip), port: nwPort)
        let conn = NWConnection(to: endpoint, using: .tcp)

        conn.stateUpdateHandler = { state in
            switch state {
            case .ready:
                conn.cancel()
                completion(true)
            case .failed(_), .cancelled:
                conn.cancel()
                completion(false)
            default:
                break
            }
        }

        conn.start(queue: queue)

        // Timeout after 1s
        queue.asyncAfter(deadline: .now() + 1.0) {
            if conn.state != .ready {
                conn.cancel()
                completion(false)
            }
        }
    }

    // MARK: - ICMP
    private func pingIPAddressICMP(_ ip: String, completion: @escaping (Bool) -> Void) {
        let config = PingConfiguration(
            pInterval: 1.0,
            withTimeout: 2.0,
            withPayloadSize: 64
        )
        SwiftPing.pingOnce(host: ip, configuration: config, queue: queue) { response in
            let success = (response.error == nil)
            completion(success)
        }
    }
}




===== NetworkUtils.swift =====
import Foundation
import Darwin

func getWiFiAddress() -> String? {
    var address: String?
    var ifaddr: UnsafeMutablePointer<ifaddrs>?

    guard getifaddrs(&ifaddr) == 0, let firstAddr = ifaddr else {
        return nil
    }
    defer { freeifaddrs(ifaddr) }

    for ptr in sequence(first: firstAddr, next: { $0.pointee.ifa_next }) {
        let interface = ptr.pointee
        let flags = Int32(interface.ifa_flags)

        if (flags & (IFF_UP|IFF_RUNNING|IFF_LOOPBACK)) == (IFF_UP|IFF_RUNNING),
           interface.ifa_addr.pointee.sa_family == UInt8(AF_INET) {
            let name = String(cString: interface.ifa_name)
            // On iOS, Wi-Fi is typically "en0"
            if name == "en0" {
                var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                let addr = interface.ifa_addr

                getnameinfo(addr,
                            socklen_t(interface.ifa_addr.pointee.sa_len),
                            &hostname,
                            socklen_t(hostname.count),
                            nil,
                            socklen_t(0),
                            NI_NUMERICHOST)

                address = String(cString: hostname)
                break
            }
        }
    }
    return address
}

/**
 Extracts prefix for 10.x.x.x, 192.168.x.x, or 172.16-31.x.x
 Returns something like "10.0.1." or "192.168.0." etc.
 If the IP is not in these private ranges, returns nil.
 */
func getLocalIPPrefix() -> String? {
    guard let wifiAddress = getWiFiAddress() else { return nil }

    let parts = wifiAddress.split(separator: ".").map { String($0) }
    guard parts.count == 4 else { return nil }

    // Check if it’s 10.x.x.x
    if parts[0] == "10" {
        // prefix is e.g. "10.0.1."
        return "\(parts[0]).\(parts[1]).\(parts[2])."
    }

    // Check if it’s 192.168.x.x
    if parts[0] == "192" && parts[1] == "168" {
        return "192.168.\(parts[2])."
    }

    // Check if it’s 172.(16-31).x.x
    if parts[0] == "172",
       let secondOctet = Int(parts[1]),
       (16...31).contains(secondOctet)
    {
        return "172.\(secondOctet).\(parts[2])."
    }

    // If we get here, it’s some other IP range, e.g. public IP
    // Decide if you want to handle that differently or just return nil
    return nil
}




===== ScanXApp.swift =====
//
//  ScanXApp.swift
//  ScanX
//
//  Created by user on 1/24/25.
//

import SwiftUI

@main
struct ScanXApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}



